clases3:
Este c√≥digo implementa dos funciones para trabajar con √°rboles binarios. La clase `Nodo` define los nodos del √°rbol, donde cada 
nodo tiene un valor y referencias a sus nodos hijo izquierdo y derecho. La funci√≥n `encontrarSucesor` toma un nodo como entrada 
y devuelve el nodo sucesor m√°s a la izquierda en el √°rbol. La funci√≥n `recorridoInordenNoRecursivo` realiza un recorrido inorden
 del √°rbol sin utilizar recursi√≥n. Utiliza una pila para simular la recursi√≥n, comenzando desde la ra√≠z y avanzando hacia la 
 izquierda mientras se apilan los nodos. Cuando no hay m√°s nodos izquierdos, se saca un nodo de la pila, se imprime su valor 
 y se mueve al nodo derecho si existe, repitiendo este proceso hasta que la pila est√© vac√≠a y no haya m√°s nodos por visitar.

Act3:
El c√≥digo comienza importando las clases necesarias de un archivo llamado "Clases3". Luego, crea un √°rbol binario de b√∫squeda 
instanciando nodos y asignando valores a sus nodos hijo izquierdo y derecho. A continuaci√≥n, llama a la funci√≥n 
`recorridoInordenNoRecursivo`, que se espera que implemente un recorrido inorden no recursivo para el √°rbol binario de b√∫squeda. 
Este recorrido se realiza t√≠picamente utilizando un enfoque basado en pilas para simular la recursi√≥n. En resumen, el c√≥digo crea 
un √°rbol binario de b√∫squeda y realiza un recorrido inorden no recursivo sobre √©l.

Clases4:
El c√≥digo implementa un √°rbol binario de b√∫squeda en Python utilizando una clase `BinarySearchTree`. Cada nodo del √°rbol se 
representa mediante la clase `Node`, que tiene una clave (`key`), un valor asociado (`value`), y referencias a sus nodos hijos 
izquierdo (`left`) y derecho (`right`). La clase `BinarySearchTree` tiene un m√©todo `insert` para insertar nodos en el √°rbol, 
donde se utiliza una funci√≥n auxiliar `_insert_recursive` para insertar de forma recursiva. Tambi√©n incluye un m√©todo `search` 
para buscar un nodo dado su clave. La funci√≥n auxiliar `_search_recursive` realiza la b√∫squeda de manera recursiva. Adem√°s, hay 
un m√©todo `inorder_traversal` para realizar un recorrido en orden del √°rbol, que utiliza la funci√≥n auxiliar `_inorder_traversal_recursive` 
para imprimir los nodos en orden ascendente de claves. Este dise√±o modular permite una implementaci√≥n limpia y eficiente de un 
√°rbol binario de b√∫squeda en Python.

Act4:
El c√≥digo utiliza una clase `BinarySearchTree` para implementar un √°rbol binario de b√∫squeda en Python. Se inicializa un √°rbol 
binario de b√∫squeda (`bst`) y se insertan varios elementos usando el m√©todo `insert`, donde se especifica una clave y un valor 
asociado. Luego, se imprime el √°rbol en orden utilizando el m√©todo `inorder_traversal`, lo que imprime los nodos en orden 
ascendente de claves. Despu√©s, se intenta insertar una clave existente con un nuevo valor, lo que deber√≠a actualizar el valor 
asociado a esa clave. Finalmente, se imprime el √°rbol nuevamente para mostrar la actualizaci√≥n. Este c√≥digo aprovecha la 
estructura de los √°rboles binarios de b√∫squeda para realizar inserciones y actualizaciones eficientes.

Clases5:
Este c√≥digo implementa una clase `Node` para representar nodos en un √°rbol y una funci√≥n `imprimirExpresion` para imprimir 
expresiones matem√°ticas en notaci√≥n infija. Cada nodo tiene un valor y referencias a los hijos izquierdo y derecho. La funci√≥n 
`imprimirExpresion` recibe la ra√≠z del √°rbol y realiza un recorrido recursivo en el √°rbol. Si el nodo actual es un operador 
(`+`, `-`, `*`, `/`), se imprimen par√©ntesis alrededor de los hijos y el operador. Si el nodo es un n√∫mero, simplemente se 
imprime el valor del nodo. Esto permite imprimir expresiones matem√°ticas de manera legible, manteniendo la jerarqu√≠a de 
operaciones.

Act5:
Este c√≥digo crea y representa √°rboles de expresiones matem√°ticas utilizando una clase `Node` para representar cada nodo del 
√°rbol y una funci√≥n `imprimirExpresion` para imprimir la expresi√≥n en notaci√≥n infija. Primero, se crea un √°rbol de expresi√≥n 
simple con dos nodos (un operador de suma y dos operandos) y se imprime la expresi√≥n. Luego, se crea un √°rbol de expresi√≥n m√°s 
complejo con cuatro nodos (un operador de suma, un operador de multiplicaci√≥n, un operador de divisi√≥n y cuatro operandos) y se 
imprime esta expresi√≥n. La impresi√≥n de las expresiones se realiza utilizando la funci√≥n `imprimirExpresion`, que recorre 
recursivamente el √°rbol de expresi√≥n para imprimir cada nodo en notaci√≥n infija.

Clases6:
Este c√≥digo define una clase llamada `Heap` en C++ para implementar un mont√≠culo (heap). El mont√≠culo se implementa utilizando un 
vector de enteros para almacenar los elementos. La clase `Heap` tiene un m√©todo privado llamado `descender` que se utiliza para
 mantener la propiedad del mont√≠culo durante las operaciones de inserci√≥n y eliminaci√≥n. El m√©todo `construirMonticulo` construye 
 un mont√≠culo m√°ximo a partir de una lista dada, mientras que el m√©todo `heapSort` ordena una lista utilizando el algoritmo de 
 ordenaci√≥n heapsort. Durante la construcci√≥n del mont√≠culo, se recorre la mitad de los elementos del vector y se llama al m√©todo
  `descender` para asegurar que el mont√≠culo se mantenga correctamente. Para la ordenaci√≥n heapsort, se construye inicialmente un 
  mont√≠culo a partir de la lista dada y luego se extraen repetidamente los elementos m√°ximos del mont√≠culo y se colocan al final
   del vector, manteniendo as√≠ la propiedad de mont√≠culo en cada paso.

Act6:
Este c√≥digo implementa el algoritmo de ordenamiento heapsort en C++. La clase `Heap` contiene funciones para construir un 
mont√≠culo (heap) a partir de una lista dada y para ordenar esa lista utilizando heapsort. En el m√©todo `descend`, se realiza el 
ajuste descendente del heap para mantener la propiedad de heap m√°ximo en el √≠ndice dado. El m√©todo `buildHeap` construye el 
mont√≠culo llamando repetidamente al m√©todo `descend` para todos los nodos no hoja del heap. El m√©todo `heapSort` utiliza 
`buildHeap` para construir el mont√≠culo inicial y luego realiza la ordenaci√≥n de la lista intercambiando el primer elemento 
(el m√°ximo del heap) con el √∫ltimo y llamando a `descend` para restaurar la propiedad del heap en el sub√°rbol restante. 
Finalmente, en la funci√≥n `main`, se crea una instancia de `Heap`, se inicializa una lista de n√∫meros, se ordena utilizando 
heapsort y se imprime la lista original y la lista ordenada.

Clases7:
Este c√≥digo implementa un mont√≠culo binario de m√°ximo utilizando la clase MonticuloBinario.
La funci√≥n heapify se encarga de mantener la propiedad del mont√≠culo, verificando y ajustando los elementos en cada iteraci√≥n.
La funci√≥n swap se utiliza para intercambiar dos elementos en el mont√≠culo.

La funci√≥n insert agrega un nuevo elemento al mont√≠culo y reajusta la estructura para mantener la propiedad del mont√≠culo.
La funci√≥n extractMax extrae y devuelve el elemento m√°ximo del mont√≠culo, reajustando la estructura despu√©s de la extracci√≥n.
Este c√≥digo se encuentra en el archivo "MonticuloBinario.h" y define las implementaciones de los m√©todos de la clase MonticuloBinario.

Clase7;
Este c√≥digo define una clase MonticuloBinario en el archivo de encabezado "MonticuloBinario.h".
La clase tiene un vector privado heap para almacenar los elementos del mont√≠culo.

Contiene m√©todos privados heapify y swap para mantener la propiedad del mont√≠culo y para intercambiar elementos, respectivamente.
Los m√©todos p√∫blicos insert y extractMax permiten agregar elementos al mont√≠culo y extraer el m√°ximo, respectivamente.
Este archivo de encabezado proporciona la interfaz para trabajar con un mont√≠culo binario de m√°ximo en C++.

Act7:
En este c√≥digo, primero se define una clase llamada MonticuloBinario en el archivo "MonticuloBinario.h" para representar un mont√≠culo binario 
de m√°ximo.Luego, en el archivo "main.cpp", se incluye la definici√≥n de esta clase y se crea una instancia de MonticuloBinario.
A continuaci√≥n, se insertan varios elementos en el mont√≠culo usando el m√©todo insert.
Finalmente, se extrae y muestra el elemento m√°ximo utilizando el m√©todo extractMax.

Clases8:
Para implementar la clase ColaPrioridad utilizando la clase MonticuloBinario, se define una nueva clase ColaPrioridad que utiliza la implementaci√≥n de MonticuloBinario para proporcionar una cola de prioridad.
La clase ColaPrioridad tiene un constructor que inicializa la cola de prioridad y dos m√©todos: agregar para agregar elementos a la cola de 
prioridad y avanzar para extraer y devolver el elemento con la mayor prioridad.

La clase MonticuloBinario proporciona las operaciones necesarias para mantener el mont√≠culo binario como un mont√≠culo m√°ximo, incluyendo la 
inserci√≥n de elementos y la extracci√≥n del m√°ximo. Al utilizar la clase MonticuloBinario, la clase ColaPrioridad aprovecha su implementaci√≥n para lograr la funcionalidad deseada.

Clase8;
Este c√≥digo implementa una nueva clase llamada PriorityQueue, que utiliza la clase BinaryHeap (Mont√≠culo Binario) para crear una cola de prioridad.
La clase PriorityQueue tiene un constructor que inicializa la cola de prioridad con un mont√≠culo binario.

El m√©todo agregar permite agregar elementos a la cola de prioridad utilizando el m√©todo insert del mont√≠culo binario.
El m√©todo avanzar extrae y devuelve el elemento con mayor prioridad utilizando el m√©todo extract_max del mont√≠culo binario.

Act8:
Este c√≥digo crea una nueva clase llamada ColaPrioridad que utiliza la clase MonticuloBinario para implementar una cola de prioridad.
La clase ColaPrioridad tiene un constructor para inicializar la cola de prioridad y m√©todos agregar y avanzar.
El m√©todo agregar permite agregar elementos a la cola de prioridad, mientras que el m√©todo avanzar extrae y devuelve el elemento con mayor prioridad.
El programa de prueba crea una instancia de ColaPrioridad, agrega algunos elementos y luego extrae y muestra los elementos de mayor prioridad de la cola uno por uno.

Act11:
El c√≥digo implementa una cola de prioridad en C++ utilizando la biblioteca est√°ndar `<queue>` para una cola y `<utility>` 
para pares. La clase `PriorityQueue` utiliza un `priority_queue` que almacena pares de `string` e `int`, donde el `int` 
representa la prioridad del elemento. El m√©todo `agregar` inserta un nuevo elemento en la cola de prioridad, mientras que 
`obtener_minimo` extrae y devuelve el elemento con la m√≠nima prioridad. El m√©todo `esta_vacia` verifica si la cola de prioridad 
est√° vac√≠a. En el programa principal, se crea una cola de prioridad, se agregan elementos con sus respectivas prioridades y luego 
se extraen y muestran los elementos en orden de prioridad. Despu√©s de agregar m√°s elementos, se extraen nuevamente para verificar 
el orden correcto de extracci√≥n seg√∫n la prioridad. Este c√≥digo demuestra el uso de una cola de prioridad para manejar elementos 
con diferentes prioridades de manera eficiente en C++.

Act12;
Este c√≥digo implementa una clase Graph para representar un grafo no dirigido utilizando un diccionario de listas por defecto de Python. La clase 
proporciona un m√©todo add_edge para agregar aristas al grafo. Luego, se implementa un m√©todo bfs para realizar una b√∫squeda en anchura desde un 
nodo inicial dado. Dentro del m√©todo bfs, se utiliza un conjunto visited para rastrear los nodos visitados y una cola queue para almacenar los 
nodos pendientes de explorar. El algoritmo contin√∫a hasta que la cola est√© vac√≠a, explorando los nodos vecinos en orden determin√≠stico utilizando 
una lista ordenada de tuplas de vecinos y pesos. Finalmente, se construye el grafo utilizando una lista de aristas predefinida y se realiza una 
b√∫squeda en anchura desde el nodo 1, mostrando el recorrido resultante.

Pregunta13;
¬øCu√°l es el tiempo de ejecuci√≥n O-grande de la funci√≥n construirGrafo? 
El tiempo de ejecuci√≥n de la funci√≥n construirGrafo depende principalmente del n√∫mero de aristas que se est√°n agregando al grafo. En el peor de 
los casos, si todas las aristas se agregan a la lista de adyacencia del grafo, el tiempo de ejecuci√≥n ser√≠a proporcional al n√∫mero total de aristas. 
Entonces, el tiempo de ejecuci√≥n en el peor caso ser√≠a ùëÇ(E), donde ùê∏  representa el n√∫mero de aristas en el grafo.

Act14;
Este c√≥digo implementa el algoritmo de Dijkstra para encontrar las distancias m√≠nimas desde un nodo de inicio dado a todos los dem√°s nodos en un 
grafo dirigido y valorado. Comienza definiendo tres clases: MonticuloBinario, ColaPrioridad, y Grafo. La clase MonticuloBinario se utiliza para 
mantener una estructura de mont√≠culo binario para gestionar las prioridades durante el proceso de Dijkstra. La clase ColaPrioridad utiliza el 
mont√≠culo binario para implementar una cola de prioridad. La clase Grafo se utiliza para representar el grafo utilizando un diccionario de 
adyacencia.

El algoritmo de Dijkstra se implementa en la funci√≥n dijkstra. Utiliza una cola de prioridad para explorar los nodos en orden de distancia 
creciente desde el nodo de inicio. En cada iteraci√≥n, selecciona el nodo con la menor distancia no visitado, lo marca como visitado y actualiza 
las distancias a sus vecinos si encuentra un camino m√°s corto. Luego, se crea un grafo utilizando una lista de aristas predefinida y se aplica el 
algoritmo de Dijkstra desde el nodo 1, mostrando las distancias m√≠nimas desde ese nodo a todos los dem√°s nodos del grafo.

Act15;
Este c√≥digo implementa el algoritmo de Dijkstra para encontrar el camino m√°s corto desde un nodo de inicio hasta todos los dem√°s nodos en un grafo 
ponderado dirigido. Comenzando con distancias infinitas para todos los nodos excepto el nodo de inicio, el algoritmo actualiza las distancias a 
medida que explora el grafo, utilizando una cola de prioridad para seleccionar el pr√≥ximo nodo a visitar. Cada paso del algoritmo se imprime en 
la consola, mostrando el nodo actual en proceso y cualquier camino m√°s corto encontrado. Al final, se devuelven las distancias finales desde el 
nodo de inicio hasta todos los dem√°s nodos en el grafo.

Act16;
Este c√≥digo define una clase Grafo que representa un grafo no dirigido con ponderaciones en las aristas. Utiliza un diccionario de listas por 
defecto para almacenar las aristas del grafo. La clase proporciona un m√©todo agregar_arista para agregar una arista al grafo, especificando los 
nodos conectados y el peso de la arista. Tambi√©n proporciona un m√©todo prim que implementa el algoritmo de Prim para encontrar el √°rbol de 
expansi√≥n de ponderaci√≥n m√≠nima comenzando desde un nodo de inicio dado.

El algoritmo de Prim comienza desde un nodo de inicio y selecciona repetidamente la arista de menor peso que conecta un nodo visitado con un 
nodo no visitado, agreg√°ndola al √°rbol de expansi√≥n y marcando el nodo conectado como visitado. El proceso contin√∫a hasta que todos los nodos 
est√©n visitados.

Al final, el m√©todo prim devuelve una lista de aristas que representan el √°rbol de expansi√≥n de ponderaci√≥n m√≠nima encontrado. Este algoritmo 
garantiza que el √°rbol de expansi√≥n de ponderaci√≥n m√≠nima contiene todas las aristas necesarias para conectar todos los nodos del grafo con el 
menor peso total posible.

Pregunta17;
¬øCu√°l es el tiempo de ejecuci√≥n O-grande para el algoritmo de Prim del √°rbol de expansi√≥n m√≠nimo?
El tiempo de ejecuci√≥n del algoritmo de Prim para encontrar el √°rbol de expansi√≥n m√≠nimo depende de la implementaci√≥n espec√≠fica y de la 
estructura de datos utilizada para representar el grafo y mantener la cola de prioridad de las aristas. Sin embargo, en general, el tiempo de 
ejecuci√≥n se puede analizar de la siguiente manera:
Complejidad temporal del bucle principal: El bucle principal del algoritmo de Prim se ejecuta una vez por cada v√©rtice en el grafo. En cada 
iteraci√≥n, se selecciona la arista de menor peso que conecta un v√©rtice en el √°rbol con un v√©rtice fuera del √°rbol. Por lo tanto, si el grafo tiene 
V v√©rtices, este bucle principal se ejecutar√° ùëâ veces. B√∫squeda de la arista de menor peso: En cada iteraci√≥n del bucle principal, se realiza una 
b√∫squeda para encontrar la arista de menor peso que conecta un v√©rtice del √°rbol con un v√©rtice fuera del √°rbol. Si se utiliza una estructura de 
datos eficiente para mantener la cola de prioridad de las aristas, como un mont√≠culo binario, esta operaci√≥n puede realizarse en tiempo 
ùëÇ(log‚Å°ùê∏), donde ùê∏ es el n√∫mero de aristas en el grafo. Dado que ùê∏ puede ser tan grande como ùëâ2 en el peor caso para un grafo completo, la 
complejidad temporal del algoritmo de Prim se puede expresar como O(VlogE) o O(VlogV2), que se simplifica a O(VlogV). En la pr√°ctica, el t√©rmino 
logV domina y el tiempo de ejecuci√≥n del algoritmo de Prim se considera O(VlogV).
Por lo tanto, la complejidad temporal del algoritmo de Prim para encontrar el √°rbol de expansi√≥n m√≠nimo es 
ùëÇ(ùëâlog‚Å°ùëâ), donde ùëâ es el n√∫mero de v√©rtices en el grafo.

Act18;
Este c√≥digo implementa el algoritmo de Prim para encontrar el √°rbol de expansi√≥n de coste m√≠nimo en un grafo ponderado no dirigido. Comenzando 
desde un nodo de inicio dado, el algoritmo selecciona iterativamente la arista m√°s corta que conecta un nodo visitado con uno no visitado, 
expandiendo as√≠ el √°rbol de expansi√≥n m√≠nimo. Cada paso del algoritmo se imprime en la consola, mostrando la arista seleccionada y cualquier 
nueva arista agregada a la cola de prioridad. Al final, se imprime el √°rbol de expansi√≥n de coste m√≠nimo encontrado.

Act19;
Este c√≥digo presenta una implementaci√≥n del m√©todo transponer para la clase Grafo, que se utiliza para obtener el grafo transpuesto. El grafo 
transpuesto de un grafo dirigido es otro grafo en el que todas las direcciones de las aristas se invierten.
El m√©todo transponer se ejecuta sobre un objeto de la clase Grafo, invierte la direcci√≥n de cada arista en el grafo y devuelve el grafo transpuesto.

El c√≥digo comienza importando la clase Grafo del archivo Clases19.py. Luego, crea un grafo de ejemplo utilizando el m√©todo agregar_arista 
para agregar varias aristas. A continuaci√≥n, llama al m√©todo transponer para obtener el grafo transpuesto y finalmente muestra tanto el grafo 
original como el grafo transpuesto.

El grafo original se imprime mostrando todas las aristas tal como se agregaron al grafo, mientras que el grafo transpuesto se imprime mostrando 
las aristas invertidas, es decir, desde los nodos de destino hacia los nodos de origen en lugar de al rev√©s. Esto proporciona una representaci√≥n 
clara de la inversi√≥n de direcciones de las aristas en el grafo transpuesto.

Clases19;
Este c√≥digo define una clase Grafo que representa un grafo dirigido utilizando un diccionario para almacenar las listas de adyacencia de cada 
v√©rtice. La clase proporciona un m√©todo agregar_arista para agregar aristas al grafo, especificando los nodos de origen y destino de la arista.

El m√©todo transponer se encarga de crear y devolver el grafo transpuesto. El grafo transpuesto de un grafo dirigido es otro grafo en el que 
todas las aristas tienen sus direcciones invertidas. Esto significa que si hay una arista dirigida de A a B en el grafo original, habr√° una 
arista dirigida de B a A en el grafo transpuesto.

El m√©todo transponer itera sobre todos los v√©rtices del grafo original y, para cada v√©rtice, itera sobre todas las aristas que salen de ese 
v√©rtice en el grafo original. Luego, agrega aristas al grafo transpuesto invirtiendo la direcci√≥n de las aristas, es decir, cambiando el orden 
de los v√©rtices de origen y destino.

Act20;
Este c√≥digo implementa el algoritmo de Floyd-Warshall para encontrar las distancias m√≠nimas entre todos los pares de v√©rtices en un grafo ponderado 
con pesos positivos o negativos.
Primero, se define el valor infinito INF y la funci√≥n floyd_warshall, que toma como entrada un grafo representado como una lista de adyacencia y 
devuelve una matriz de distancias m√≠nimas entre todos los pares de v√©rtices.

La funci√≥n obtener_grafo solicita al usuario ingresar el n√∫mero de v√©rtices en el grafo y luego solicita las aristas del grafo en el formato 
'origen destino peso'. Estas aristas se almacenan en la lista de adyacencia del grafo.
En la funci√≥n main, se ejecuta un bucle donde se obtiene un grafo del usuario, se aplica el algoritmo de Floyd-Warshall al grafo y se muestran 
las distancias m√≠nimas entre todos los pares de v√©rtices. El programa ofrece al usuario la opci√≥n de ingresar otro grafo o finalizar la ejecuci√≥n.

Este c√≥digo proporciona una manera interactiva de calcular las distancias m√≠nimas entre todos los pares de v√©rtices en un grafo, permitiendo al 
usuario ingresar los datos del grafo en tiempo de ejecuci√≥n.
El c√≥digo proporciona una implementaci√≥n limpia y eficiente del m√©todo transponer que permite obtener el grafo transpuesto de manera sencilla y 
directa a partir de un grafo dirigido dado.


Clasesp1:
El c√≥digo define dos clases en Python: `Nodo` y `ArbolBinario`. La clase `Nodo` representa un nodo en un √°rbol binario, con un 
valor dado y referencias a sus nodos hijos izquierdo y derecho. La clase `ArbolBinario` representa el √°rbol binario en s√≠, con un 
constructor que inicializa la ra√≠z como `None` y m√©todos para operar en el √°rbol. Estos m√©todos incluyen `numNodos`, que devuelve 
la cantidad de nodos utilizando un enfoque recursivo, `_numHojasRecursivo`, que devuelve el n√∫mero de hojas mediante un enfoque 
recursivo, `profundidad`, que calcula la longitud del camino m√°s largo desde la ra√≠z hasta una hoja, y `espejo`, que devuelve un 
nuevo √°rbol que es el espejo del √°rbol actual, intercambiando los nodos hijos izquierdos y derechos de cada nodo, tambi√©n 
utilizando un enfoque recursivo. En resumen, el c√≥digo proporciona una estructura b√°sica de √°rbol binario y operaciones para 
manipularlo, como contar nodos, calcular la profundidad y crear el √°rbol espejo.

p1:
El c√≥digo importa las clases `ArbolBinario` y `Nodo` desde un m√≥dulo llamado `Clasesp1`. Luego, crea un objeto `ArbolBinario` 
llamado `arbol`. Se asignan nodos a la ra√≠z y a sus hijos izquierdo y derecho. Posteriormente, se verifican algunas operaciones 
del √°rbol, como la cantidad de nodos, el n√∫mero de hojas y la profundidad, utilizando los m√©todos proporcionados por la clase 
`ArbolBinario`. Despu√©s, se crea un √°rbol espejo llamando al m√©todo `espejo()` del √°rbol original y se imprime tanto el √°rbol 
original como su espejo para verificar la operaci√≥n de espejado. Este c√≥digo muestra c√≥mo utilizar las clases `ArbolBinario` y 
`Nodo` para trabajar con √°rboles binarios y realizar operaciones como calcular la profundidad y crear el √°rbol espejo.

Clasesp3:
El c√≥digo importa la clase `ArbolBinarioBusqueda` desde un m√≥dulo externo y utiliza esta clase para crear un √°rbol binario de 
b√∫squeda (ABB) a partir de una lista dada. La implementaci√≥n de la clase `ArbolBinarioBusqueda` incluye m√©todos para insertar 
elementos manteniendo la propiedad de √°rbol de b√∫squeda binaria, as√≠ como para realizar recorridos en el √°rbol (preorden, inorden,
 postorden y por anchura) y para calcular la cantidad de nodos, el n√∫mero de hojas y la profundidad del √°rbol de manera recursiva.
  Estas operaciones permiten manipular eficientemente el √°rbol binario de b√∫squeda y obtener informaci√≥n relevante sobre su 
  estructura.

p3:
El c√≥digo importa la clase `ArbolBinarioBusqueda` desde un m√≥dulo llamado `Clasesp3` y utiliza esta clase para crear un √°rbol 
binario de b√∫squeda (ABB) a partir de una lista dada. Luego, recorre la lista e inserta cada elemento en el √°rbol mediante el 
m√©todo `insertar`. Posteriormente, se imprimen los recorridos preorden, inorden, postorden y por anchura del √°rbol, utilizando 
los m√©todos correspondientes de la clase `ArbolBinarioBusqueda`. Finalmente, se verifican los algoritmos para determinar la 
cantidad de nodos, el n√∫mero de hojas y la profundidad del √°rbol, utilizando los m√©todos `cantidad_nodos`, `cantidad_hojas` y 
`profundidad` proporcionados por la clase `ArbolBinarioBusqueda`. Este c√≥digo muestra c√≥mo crear y operar con un √°rbol binario
 de b√∫squeda utilizando la implementaci√≥n proporcionada en el m√≥dulo `Clasesp3`.

Clasesp5_2:
El c√≥digo implementa una cola de prioridad utilizando un mont√≠culo binario como base. La clase `PriorityQueue` tiene un constructor
 que inicializa un mont√≠culo binario vac√≠o a trav√©s de la importaci√≥n de la clase `BinaryHeap` desde el m√≥dulo `Clasesp5`. La 
 cola de prioridad permite agregar elementos con una clave y una prioridad utilizando el m√©todo `agregar`, que inserta una tupla 
 de clave y prioridad en el mont√≠culo. El m√©todo `obtener_minimo` extrae y devuelve el elemento con la m√°xima prioridad del 
 mont√≠culo, ya que el mont√≠culo utilizado es un mont√≠culo m√°ximo. El m√©todo `esta_vacia` verifica si la cola de prioridad est√° 
 vac√≠a comprobando si el mont√≠culo interno est√° vac√≠o. Esta implementaci√≥n proporciona una estructura eficiente para mantener 
 elementos ordenados por prioridad y realizar operaciones de inserci√≥n y extracci√≥n en tiempo logar√≠tmico en funci√≥n del tama√±o 
 de la cola de prioridad.

Clasesp5:
El c√≥digo implementa una estructura de datos de mont√≠culo binario (Binary Heap) en Python. La clase `BinaryHeap` tiene un 
constructor que inicializa una lista vac√≠a para almacenar los elementos del mont√≠culo. Adem√°s, implementa m√©todos para insertar 
un nuevo elemento (`insert`) y extraer el m√°ximo elemento (`extract_max`). Para mantener la propiedad de mont√≠culo, se utilizan 
m√©todos privados `_percolate_up` y `_percolate_down` que realizan el ajuste ascendente y descendente, respectivamente, despu√©s de√ß
 una inserci√≥n o extracci√≥n. El ajuste ascendente (`_percolate_up`) compara el elemento insertado con su padre y lo intercambia 
 si es mayor, mientras que el ajuste descendente (`_percolate_down`) compara el elemento en la posici√≥n ra√≠z con sus hijos y lo 
 intercambia con el mayor hijo si es necesario. Esto garantiza que el elemento m√°ximo est√© siempre en la posici√≥n ra√≠z del 
 mont√≠culo, lo que permite realizar operaciones de inserci√≥n y extracci√≥n eficientes en tiempo logar√≠tmico en funci√≥n del 
 tama√±o del mont√≠culo.


p5:

El c√≥digo importa la clase `PriorityQueue` desde el m√≥dulo `Clasesp5_2` para crear una cola de prioridad. Luego, se agregan 
varias tuplas `(clave, prioridad)` a la cola utilizando el m√©todo `agregar`, donde cada tupla representa un elemento con una 
clave y una prioridad. Se extraen elementos de la cola de prioridad utilizando el m√©todo `obtener_minimo`, que devuelve el 
elemento con la m√°xima prioridad, asegurando que se extraigan los elementos en orden de prioridad. Los elementos extra√≠dos se 
imprimen para verificar que est√°n en el orden correcto de acuerdo con sus prioridades. Despu√©s de agregar m√°s elementos a la 
cola y volver a extraerlos, se verifica nuevamente el orden de los elementos para asegurarse de que se mantenga la propiedad de 
la cola de prioridad, donde los elementos se extraen en orden ascendente de prioridad. Este c√≥digo muestra c√≥mo usar la clase 
`PriorityQueue` para crear una cola de prioridad y realizar operaciones de inserci√≥n y extracci√≥n de elementos en funci√≥n de la 
prioridad.

P2;
Este programa en C++ implementa cuatro tipos de recorridos en un √°rbol binario: preorden, inorden, postorden y en anchura.
La estructura del √°rbol se define mediante la estructura TreeNode, que contiene un valor entero y punteros a los nodos hijo izquierdo y derecho.

Las funciones preOrder, inOrder, postOrder y breadthFirst realizan los respectivos recorridos en el √°rbol.
En la funci√≥n main, se construye un √°rbol con nodos y se realizan los cuatro tipos de recorridos llamando a las funciones correspondientes. 
Los resultados se imprimen en la consola.

P4;
Este programa en C++ implementa cuatro tipos de recorridos en un √°rbol binario: preorden, inorden, postorden y en anchura.
La estructura del √°rbol se define mediante la estructura TreeNode, que contiene un valor entero y punteros a los nodos hijo izquierdo y derecho.

Las funciones preOrder, inOrder, postOrder y breadthFirst realizan los respectivos recorridos en el √°rbol.
En la funci√≥n main, se construye un √°rbol con nodos y se realizan los cuatro tipos de recorridos llamando a las funciones correspondientes. 
Los resultados se imprimen en la consola.








